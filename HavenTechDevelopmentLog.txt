javascript haven uses callbacks to wait for the asyncronous javascript requests
and continue loading the parts of the scene

when loading a model, requests for the shader are made before the shader has loaded
IsHit, IsTransparent requires the shader(fragment and vertex program) to be in the Graphics instance shaders array
in a callback this instead of thisP may be being used, or the "undefined" name may be causing the shader not to be found in the array

with the rendering running
next is to fix the model exporters so that content can be imported

also ideas for the haven tech engine, physics simulation
allow for destructable objects, constraints (ropes and springs), fluid flow,
heat flow, radiance, and chemical interactions

in game engines fire effects are usually shown as an animated sprite and
replacing models with different ones once they reach a certian amount of damage

with the digital molecular matter physics engine, and in red faction, all objects
are destructable by splitting into different meshes algorithmicaly

by extending the box eye point mass spring model, allowing for the spring constraints to
break, assigning chemical labels to each point mass, modeling interactions between the
point masses (allowing for them to combine/ seperate and change label), using a oct tree
to prevent n^2 collision tests, and simulating the e and m fields (heat and energy state) between points
some approximations might have to be made for charge flow and magnetisim for it to be run in realtime
damping, resonance and system energy checks may be used to prevent runaway spring oscilations (due to the simple iterative solver)
haven tech physics could allow for a loose reality simulation

simulating mechanics such as
wheels, magnents, convective / radiative heating to melt and cast materials
fluid flow with bouyancy, waves and internal flow (2, 3 phase flow), differential pressure
lifting surfaces (high speed flow -> lower off normal pressure)
soft / flexible objects (bouncy ball, tree leaves, jello, goo)
surface tension, electrowetting, solvents
creating a battery out of elements found, making a lightbulb with wire, geometry and melted glass
vaccum/inert gas filled enclosure,crafting oxide semiconductors
rigid fracture, cement, brittle metal, dry dirt
dirt cave in, affect of moisture on types of dirt depending on dirt makeup (silica, limestone, clay (bentonite), decomposed plants)
plant growth, soil erosion with rain
human and animal skin changing color from blood/fluid flow when pressed, musculature, organs, fluids, bleeding, loss of limbs, damage affect on alertness and mobility, drugs, aging
eating, effects of enviroment humidity, o2, waste, chemicals, diseases spread between organisims, healing
snow fall, dust when objects move, condensation with pressure increase / temperature drop pv=nrt
freezing of fluids / flexible objects, crystalization
evaporation (steam) and sublimination
planitary orbits, solar system energy flux, weather
oxidation, fire (C-H6 + O2 -> CO2 + H2O), rust (Al + O2 -> AlO), halides and inert gasses to put out fire
color and texture based on compound, ionization and electron energy state (metal blue/burnishing as heated in air with O2)
refractive, reflective, iso/aniso diffuse surfaces, volume baked lighting contribution maps for updating when objects change
fog, and scattering media

allowing for interactive stories involving
demolition, building construction, farming, solar array plants, car crashes, sex, clothing,
wave riding, space travel, hacking, spy networks, mental and social disorder/order, furry animals, plants,
space ecosystems, crafting and user discovery of principles and techniques
if the simulation can approximate constructing objects from different ones as well as destructing them then it is good,
if it can be used to discover new real world science and objects then it is really good
In games like MDK2 and Sam and Max different objects had to be gathered to build different ones

fluids and finite element simulations take allot of computation power, so the fidelity
of the simulation will have to be scaled based on how long frames take to render and
leave the rest of the enviroment static (as in a static rigid body game world)
the game will not realistically be able to convince someone it is a real world, but the closer to gets
potentially the less user fatigue and longer someone is likely to play (and maybe generate content for it)
the success of minecraft is based on this principle


models can be exported from blender with verticies assigned, faces, edges, and material (chemical) type, 
with volumetric inner verticies having only type and edges (springs)

hierarchy of simulation resolution
static surface reflectance simulation -> rigid body rotation translation inertia -> point mass mesh 

for objects at the background temperature not undergoing reactions or emitting fields,
the simulation is kept corse, a static simulation until colliding with or interacting with sufficent external gradiant
if the forces only generate a restorative force, then it is generated and the object goes back to static simulation,
if it exceeds threshold causing the object to move, induce fields, change temperature, or chemically react, then those simulations run on the object
until the field and force gradients fall below threshold value. then those simulations are skipped during frame updates to decrease computation load

shrink wrap convex hull surface meshing
to find the surfaces of point mass objects a plane is swept along an axis sorting the points by their value on the axis,
the next point closest to it is picked with the

magnetics and magnetic simulation - mri (spin waves) is the best way to image soft objects, data and inspiration from it in simulation may give new expirences
magnetisim is circular electric motion. every electric motion causes dopplar shift, displacement of other objects of similar frequency

in order to simulate these phenomina - a unified model is desired. best current idea is spectral electro magnetic wave frequency simulation. with asynchronous /offline calculation and caching and error bound generalization to use a combination of precomputed directional sperical harmonic lighting and geometry, raytracing, rasterization, and low level simulation of individual interactions instanced to reduce duplicate computation

effictively pipelining and caching - having the most probable scenarios precomputed and preform the minimal computations to generate dynamic content
