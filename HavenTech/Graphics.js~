//Graphics.js

//helper function for printing gl errors
function CheckGLError(where){
    var error = gl.getError();
    var iter = 0;
    while(error != gl.NO_ERROR && iter < 100){
        alert(where + ': glError errorNum:' + iter + ' 0x' + error.toString(16));
        error = gl.getError();
        ++iter;
    }
    if(iter > 0)
        return true;
    return false;
}

function drawSquare(graphics) { // Draw the picture
    var vertices = [  0.0,  0.5, 0.0,
                     -0.5, -0.5, 0.0,
                      0.5, -0.5, 0.0 ]; 
    var verts = new Float32Array(vertices);

    attributeSetFloats( graphics.currentProgram, "position",  3, verts );
    attributeSetFloats( graphics.currentProgram, "normal",    3, verts );
    attributeSetFloats( graphics.currentProgram, "texCoord", 2, verts );
    gl.drawArrays(gl.TRIANGLES, 0, 3); 
    gl.flush();
}

function attributeSetFloats( prog, attr_name, rsize, arr) {
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, arr, gl.DYNAMIC_DRAW);
    var attr = gl.getAttribLocation( prog, attr_name);
    gl.enableVertexAttribArray(attr);
    gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}

function Graphics(canvasIn, bpp, depthIn){

    //maps used to keep track of primative graphics objects
    this.textures = {};
    this.shaders = {};
    this.quadMeshes = {};
    this.textureRefCts = {};
    this.shaderRefCts = {};
    this.quadMeshRefCts = {};

    var maxLights = 8;
    var numLightsBounded = 0;

    var screenWidth = canvasIn.width;
    var screenHeight = canvasIn.height;
    var bpp = 0;

    //information about the rendering state (used to minimize the number of calls to gl)
    var tex2Denb         = false;
    var lightingEnb      = false;
    var colorMaterialEnb = false;
    var depthMaskEnb     = false;
    var depthTestEnb     = false;
    var currentTexId     = -1;
    var currentColor     = [0.0, 0.0, 0.0, 0.0];
    var ambAndDiffuse    = [0.0, 0.0, 0.0, 0.0];
    var emission         = [0.0, 0.0, 0.0, 0.0];
    var specular         = [0.0, 0.0, 0.0, 0.0];
    var shinyness        = 0;
    
    //globally used constants
    this.vertCard = 3;
    this.normCard = 3;
    this.uvCard   = 2;
    this.matrixCard = 4*4;

    //for clearing the color buffer
    this.Clear = function(){ 
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    //for clearing depth between scene renderings
    this.ClearDepth = function(){
        gl.clear(gl.DEPTH_BUFFER_BIT);
    }   

    //functions for fog
    this.EnableFog = function(clipNear, clipFar) {
        gl.Enable(gl.FOG);
        gl.Fogx(gl.FOG_MODE, gl.LINEAR);
        var params = [];
        params[0]= 1.0; params[1]= 1.0; params[2]= 1.0; params[3]= 1.0;
        gl.Fogfv(gl.FOG_COLOR, params);
        gl.Fogf(gl.FOG_START, clipNear);
        gl.Fogf(gl.FOG_END, clipFar);
    }
    this.DisableFog = function() {glDisable(gl.FOG);}

    this.GetScreenWidth = function(){ return screenWidth; }
    this.GetScreenHeight = function(){ return screenHeight; }
    this.GetScreenAspect = function(){ return screenWidth/screenHeight; }
        
    //functions for altering the rendering state
    this.enableTexture2D = function(val){
        if(tex2Denb != val){
            tex2Denb = val;
            if(val)
                gl.Enable(gl.TEXTURE_2D);
            else
                gl.Disable(gl.TEXTURE_2D);
        }
    }
    this.enableLighting = function(val){
        if(lightingEnb != val){
            lightingEnb = val;
            gl.uniform1f(gl.getUniformLocation(this.currentProgram, 'lightingEnb'), lightingEnb);
        }
    }
    this.enableDepthMask = function(val){
        if(depthMaskEnb != val){
            depthMaskEnb = val;
            val ? gl.depthMask(gl.TRUE) : gl.depthMask(gl.FALSE);
        }
    }
    this.enableDepthTest = function(val){
        if(depthTestEnb != val){
            depthTestEnb = val;
            val ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST);

        }
    }
    this.setTexture = function(texId){
        if(currentTexId != texId){
            currentTexId = texId;
            gl.bindTexture(gl.TEXTURE_2D, currentTexId);
        }
    }
    this.setColor = function(col){
        if( !Vect3_Cmp(currentColor, col) ){
            Vect3_Copy(currentColor, col);
            gl.uniform4fv(gl.getUniformLocation(this.currentProgram, 'color'), currentColor);
        }
    }
    this.setAmbientAndDiffuse = function(col){
        if(!Vect3_Cmp(ambAndDiffuse, col)){
            Vect3_Copy(ambAndDiffuse, col);
            gl.uniform4fv(gl.getUniformLocation(this.currentProgram, 'ambient'), ambAndDiffuse);
        }
    }
    this.setEmission = function(col){
        if(!Vect3_Cmp(emission, col)){
            Vect3_Copy(emission, col);
            gl.uniform4fv(gl.getUniformLocation(this.currentProgram, 'emission'), emission);
        }
    }
    this.setSpecular = function(col){
        if(!Vect3_Cmp(specular, col)){
            Vect3_Copy(specular, col);
            gl.uniform4fv(gl.getUniformLocation(this.currentProgram, 'specular'), specular);
        }
    }
    this.setShinyness = function(exp){
        if(shinyness != exp){
            shinyness = exp;
            gl.uniform1f(gl.getUniformLocation(this.currentProgram, 'shinyness'), shinyness);
        }
    }

    this.ClearLights = function(){
        for(var i=0; i<this.maxLights; ++i)
            gl.uniform1f(gl.getUniformLocation(this.currentProgram, 'lightEnb[0]'), 0);
        this.numLightsBounded = 0;
    }
    this.BindLight = function(light)
    {
        if(numLightsBounded >= maxLights){
            alert("Graphics: error Max number of lights already bound.\n");
            return;
        }
        this.enableLighting(true);
        light.BindToGL(this.numLightsBounded);
        ++this.numLightsBounded;
    }

    //content access functions
    this.CopyShader = function(newName, newSceneName, oldShader) {}
    this.GetShader = function( filename, sceneName, readyCallbackParams, shaderReadyCallback ){
        var concatName = filename + sceneName;
        var shader = this.shaders[ concatName ];
        if( shader === undefined ) {
            //shader is not loaded, load the new shader and return it
            new Shader( filename, sceneName, readyCallbackParams, function( newShader, readyCallbackParams1 ){
                if( newShader.isValid ){
                    graphics.shaders[concatName] = newShader;
                    shaderReadyCallback(newShader, readyCallbackParams1);
                }
            });
        }else{
           shaderReadyCallback(shader, readyCallbackParams);
        }
    }
    this.UnrefShader = function(filename, sceneName) {}
    this.AppendTexture = function(textureName, sceneName, newValidTexture){
        var concatName = textureName + sceneName;        
        this.textures[concatName] = newValidTexture;
    }
    this.GetTexture = function(filename, sceneName, textureReadyCallback) {
        var concatName = filename + sceneName;
        var texture = this.textures[concatName];
        if(texture === undefined) {
            //texture is not loaded, load the new texture and have it return when it's ready
            new Texture(filename, sceneName, textureReadyCallback);
        }else{
            //the texture is ready, have it return through the callback
            textureReadyCallback(texture);
        }
    }
    this.UnrefTexture = function(filename, sceneName) {}
    this.GetQuadMesh = function(filename, sceneName, readyCallbackParameters, quadMeshReadyCallback) {
        var concatName = filename + sceneName;
        var quadMesh = this.quadMeshes[concatName];
        if(quadMesh === undefined){
            //mesh is not loaded, load the new mesh and return it
            var newMesh = new QuadMesh(filename, sceneName);
            this.quadMeshes.concatName = newMesh;
            quadMeshReadyCallback( newMesh );
        }
        quadMeshReadyCallback( quadMesh );
    }
    this.UnrefQuadMesh = function(filename, sceneName) {}

    //initialization code
    gl = WebGLUtils.setupWebGL(canvasIn);

    //setup the gl state
    gl.clearColor(0.6, 0.7, 1.0, 1.0);

    //gl.viewport(0, 0, screenWidth, screenHeight);

    gl.disable(gl.CULL_FACE);
    //gl.cullFace(gl.BACK);

    //enable depth testing
    //gl.depthFunc(gl.LESS);
    //this.enableDepthMask(true);

    //enable blending
    //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    //gl.enable(gl.BLEND);

    //load and compile the program
    this.currentProgram = gl.createProgram();

    var textFile = loadTextFileSynchronous('shaders/frayenVertShader.vsh');
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, textFile);
    gl.compileShader(vertexShader);
    if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) && gl.getShaderInfoLog(vertexShader))
        alert('vertex shader log: ' + gl.getShaderInfoLog(vertexShader));
    gl.attachShader(this.currentProgram, vertexShader);

    textFile = loadTextFileSynchronous('shaders/frayenFragShader.fsh');
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, textFile);
    gl.compileShader(fragmentShader);
    if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) && gl.getShaderInfoLog(fragmentShader))
        alert('fragment shader log: ' + gl.getShaderInfoLog(fragmentShader));
    gl.attachShader(this.currentProgram, fragmentShader);

    gl.validateProgram(this.currentProgram);
    gl.linkProgram(this.currentProgram);
    if(!gl.getProgramParameter(this.currentProgram, gl.LINK_STATUS) && gl.getProgramInfoLog(this.currentProgram))
        alert('gl currentProgram status: ' + gl.getProgramInfoLog(this.currentProgram));
    gl.useProgram(this.currentProgram);

    //clear the render buffer
    this.Clear();

    drawSquare(this);
        
    //set the rendering state varaibles (init them to 0 then set to 1 to ensure we are tracking the gl state)
    var temp = [1.0,1.0,1.0,1.0];
    this.setColor(temp);
    this.setAmbientAndDiffuse(temp);
    this.setEmission(temp);
    this.setSpecular(temp);
    this.setShinyness(1.0);

    //lighting setup
    this.enableLighting(true);
    CheckGLError("Graphics::end constructor ");
}
